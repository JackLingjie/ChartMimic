Here are some instructions that are being fed to a generative AI model as instruction tuning during the training of a Vision language model.  
  
"You are an expert Python developer who specializes in writing matplotlib code based on a given picture. I found a very nice picture in a STEM paper, but there is no corresponding source code available. I need your help to generate the Python code that can reproduce the picture based on the picture I provide.\nNote that it is necessary to use figsize=({width}, {height}) to set the image size to match the original size.\nNow, please give me the matplotlib code that reproduces the picture below.",

Note: 
1.Try not to repeat the verb for each instruction to maximize diversity. 
2.The languages used for the instruction should be diverse. For example, you should combine questions with imperative instructions. 
3.The instructions should be in English. 
4.The instructions should be at least 1 to 4 sentences long. 
5.Instructions should be clear and precise. 
6.Please provide 20 examples.


每个指令都应该有对图像尺寸figsize=({width}, {height})要求的提示

6.Each should be 




Here are some instructions that are being fed to a generative AI model as instruction tuning during the training of a Vision language model.  
  
"You are an expert Python developer who specializes in writing matplotlib code based on a given picture. I found a very nice picture in a STEM paper, but there is no corresponding source code available. I need your help to generate the Python code that can reproduce the picture based on the picture I provide.\nNote that it is necessary to use figsize=({width}, {height}) to set the image size to match the original size.\nNow, please give me the matplotlib code that reproduces the picture below.",

Note: 
1.Try not to repeat the verb for each instruction to maximize diversity. 
2.The languages used for the instruction should be diverse. For example, you should combine questions with imperative instructions. 
3.The instructions should be in English. 
4.The instructions should be at least 1 to 4 sentences long. Either an imperative sentence or a question is permitted.
5.Instructions should be clear and precise. 
6.Please provide 20 examples.


每个指令都应该有对图像尺寸figsize=({width}, {height})要求的提示

6.Each should be 


import json  
import os  
from concurrent.futures import ThreadPoolExecutor, as_completed  
# import logging  
from tqdm import tqdm  
from gpt4o import Openai, API_INFOS  
  
# 配置日志记录  
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')  
  
prompt_template = """  
Please modify the code between <Original Code> according to the requirements, then output the REVISED CODE ,<CATEGORY>, <CHART SIZE> following the format provided at the end.

<Original Code>
{RAW_CODE}  
<Original Code>



Please follow the reference output format for modification:  

## Reference output format:  
  
<REVISED CODE BEGIN>  

  
<REVISED CODE END>  
  
<CATEGORY>: [Line]  
<CHART SIZE>: (7.0, 7.0)  

Your output:
""" 

# 读取 JSON 数据  
def load_data(file_path):  
    try:  
        with open(file_path, 'r') as f:  
            return json.load(f)  
    except Exception as e:  
        print(f"Error loading data from {file_path}: {e}")  
        return []  
  
# 调用 GPT API 并解析响应  
def get_revised_text(client, instruction, prompt_template, max_tokens=2048):  
    content = prompt_template.format(RAW_CODE=instruction)  
    # with open("debug.txt", "w") as f:
    #     f.write(content)
    try:  
        gpt_answer = client.get_response(content=content, max_tokens=max_tokens)  
    except Exception as e:  
        print(f"Error calling GPT API: {e}")  
        return "", "", "", ""  
  
    if not gpt_answer:  
        return "", "", "", ""  
  
    revised_text = extract_revised_text(gpt_answer)  
    category = extract_category_from_gpt_answer(gpt_answer)  
    chart_size = extract_size_from_gpt_answer(gpt_answer)  
  
    return revised_text, category, chart_size, gpt_answer  
  
def extract_revised_text(gpt_answer):  
    start = gpt_answer.find("<REVISED CODE BEGIN>") + len("<REVISED CODE BEGIN>")  
    end = gpt_answer.find("<REVISED CODE END>", start)  
    return gpt_answer[start:end].strip() if start != -1 and end != -1 else ""  
  
def extract_category_from_gpt_answer(gpt_answer):  
    start = gpt_answer.find("<CATEGORY>: [") + len("<CATEGORY>: [")  
    end = gpt_answer.find("]", start)  
    return gpt_answer[start:end].strip() if start != -1 and end != -1 else ""  
  
def extract_size_from_gpt_answer(gpt_answer):  
    start = gpt_answer.find("<CHART SIZE>: (") + len("<CHART SIZE>: (")  
    end = gpt_answer.find(")", start)  
    size_str = gpt_answer[start:end].strip() if start != -1 and end != -1 else ""  
    try:  
        width, height = map(float, size_str.split(','))  
        return (width, height)  
    except ValueError:  
        return (0.0, 0.0)  
  
# 处理单行数据  
def process_row(index, client, row, prompt_template, max_tokens=2048):  
    code = row.get('text', '').strip()  
    revised_text, category, chart_size, gpt_answer = get_revised_text(  
        client, code, prompt_template, max_tokens=max_tokens  
    )  
  
    result = {  
        'index': index,  
        'revised_text': revised_text,  
        'category': category,  
        'chart_size': chart_size,  
        'gpt_answer': gpt_answer  
    }  
  
    result.update(row)  
    return result 

def main():  
    save_path = "/mnt/lingjiejiang/multimodal_code/data/chart_data/github_chart/merged_empty_data_processed.json"
    output_dir = '/mnt/lingjiejiang/multimodal_code/data/chart_data/revised_code_supply'  
    os.makedirs(output_dir, exist_ok=True)  
  
    data = load_data(save_path)  
      
    # data = data[:10]
    
    clients = [Openai(apis=[API_INFOS[i]]) for i in range(len(API_INFOS))]  
    print(f"len(clients): {len(clients)}")
    max_tokens = 2048  
    batch_size = 5000  
    revised_data = []  
  
    with ThreadPoolExecutor(max_workers=len(clients)) as executor:  
        futures = [  
            executor.submit(  
                process_row, i, clients[i % len(clients)], row, prompt_template, max_tokens  
            ) for i, row in enumerate(data)  
        ]  
  
        for i, future in enumerate(tqdm(as_completed(futures), total=len(futures))):  
            revised_data.append(future.result())  
            if (i + 1) % batch_size == 0:  
                batch_number = (i + 1) // batch_size  
                intermediate_file = os.path.join(output_dir, f"intermediate_batch_empty_{batch_number}.json")  
                with open(intermediate_file, 'w') as f:  
                    json.dump(revised_data, f, indent=0)  # 将列表写入 JSON 格式  
  
    # 最后保存完整结果  
    final_file = os.path.join(output_dir, "final_output_empty.json")  
    with open(final_file, 'w') as f:  
        json.dump(revised_data, f, indent=0)  # 将列表写入 JSON 格式  
  
if __name__ == "__main__":  
    main()  